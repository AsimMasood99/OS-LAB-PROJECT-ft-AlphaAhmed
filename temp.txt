#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include "parser.h"
#include <cjson/cJSON.h>
#include <string.h>

int printInFileFlag = 0; // this flag will become 1 when the server is sending file data to client
char *Filename;
int just_keep_printing = 0; // this bool is 1 when the server is sending the files data to client so the client will not take any commands
int count_it_came_in=1;
char *extract_filename(char *path)
{

    char *last_slash = strrchr(path, '/');

    if (last_slash == NULL)
    {
        return path;
    }

    return last_slash + 1;
}

int getFileSize(char *path)
{
    struct stat fileInfo;
    stat(path, &fileInfo);
    return fileInfo.st_size;
}

// checking if the server is ready to receive file and then send file
void processServerResponse(int clinetSocket, char *response, cJSON *commandJson)
{
    cJSON *responseJson = cJSON_Parse(response);
    cJSON *status = cJSON_GetObjectItem(responseJson, "status");
    cJSON *command = cJSON_GetObjectItem(responseJson, "command");
    cJSON *_Filename = cJSON_GetObjectItem(responseJson, "filename");
    printf("Count it came in %i\n",count_it_came_in);
    count_it_came_in++;
    if(count_it_came_in==3)
    {
        printf("File content : %s\n",response);
        printf("Flag condition %i\n",printInFileFlag);
    }
    // if(command!=NULL)
    // {
    //     printf("\n Commad : %s\n", command->valuestring);
    // }
    if (strcmp(status->valuestring, "failed") == 0)
    {
        printf("Filed error from server side\n");
    }
    if (strcmp(command->valuestring, "upload") == 0)
    {
        printf("reaching upload if\n");
        printf("hi\n");
        cJSON *path = cJSON_GetObjectItem(commandJson, "path"); // /home/ahmad/filename.txt
        if (strcmp(status->valuestring, "ready") == 0)
        {
            int bytesRead = 0;
            char stream[1024];
            //"ab" is the file mode:
            // "a" (append): This mode opens the file in append mode. It creates the file if it doesn't exist, and if the file exists, it opens the file for writing at the end (appends to it).
            // "b" (binary mode): Since this is binary mode, it treats the file as a binary file, not a text file, so it doesnâ€™t process newline characters or encoding transformations (like \r\n on Windows).
            FILE *file = fopen(path->valuestring, "rb");
            char *Msg = malloc(256);
            sprintf(Msg, "{\"command\":\"upload\",\"status\":\"incoming\", \"filename\":\"%s\",\"filesize\":\"%i\"}", extract_filename(path->valuestring),getFileSize(path->valuestring));

            printf("killing command:%s", Msg);
            send(clinetSocket, Msg, strlen(Msg), 0);
            printf("Please wait while file is being uploded ...\n");
            // while ((bytesRead = fread(stream, 1, sizeof(stream), file)) > 0)
            // {
            //     printf("%s\n",stream);
            //     send(clinetSocket, stream, bytesRead, 0);
            // }

            while (fgets(stream, 1024, file) != NULL)
            {
                printf("%s", stream);
                send(clinetSocket, stream, strlen(stream), 0);
            }
            
            // add an end of file dilimiter here as such the Msg below doesnt gets cut in 2 strings on server side .. on server i have same size buffer

            Msg = "{\"status\":\"success\"}";
            printf("File uploaded Successfully\n");
            send(clinetSocket, Msg, strlen(Msg), 0);
        }
    }
    else if (strcmp(command->valuestring, "download") == 0 || printInFileFlag == 1)
    {
        printf("Reached the download if\n");
        if (printInFileFlag == 1)
        {
            printf("Reached the print if\n");
            //+++++++++++++++++++++++++++++++++++++++++++++++++++
            // if (strcmp(status->valuestring, "success") == 0)
            // {
            //     printInFileFlag = 0;
            //     printf("Closing\n");
            // }
            if (strstr(response, "{\"status\":\"success\"}"))
            {
                printInFileFlag = 0;
                printf("Closing the downloaded file in client\n");
            }
            else
            {
                printf("File name in which client is about to write: %s\n",Filename);
                FILE *file = fopen(Filename, "rb");
                if (file)
                {
                    fprintf(file, "%s", response);
                    fclose(file);
                }
                else
                {
                    perror("Error opening file for writing");
                    printInFileFlag = 0;
                }
            }
        }
        // this is just to
        e